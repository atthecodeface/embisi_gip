#a Copyright
#  
#  This file 'test.batch' copyright Gavin J Stark 2003, 2004
#  

#a Variables
int vcd_skip_length
int run_length
int vcd_create
string vcd_full_filename
string vcd_filename

set vcd_create 1

#a Main
beq env_int("prefetch_tests") 0 skip_prefetch_tests
gosub gip_prefetch_tests
skip_prefetch_tests:

beq env_int("system_scheduler_tests") 0 skip_system_scheduler_tests
gosub gip_system_scheduler
skip_system_scheduler_tests:

beq env_int("system_ethernet_tests") 0 skip_system_ethernet_tests
gosub gip_system_ethernet
skip_system_ethernet_tests:

beq env_int("system_alu_tests") 0 skip_system_alu_tests
gosub gip_system_alu
skip_system_alu_tests:

beq env_int("system_microkernel_tests") 0 skip_system_microkernel_tests
gosub gip_system_microkernel
skip_system_microkernel_tests:

end

#a Gip prefetch tests
#f gip_prefetch_tests
gip_prefetch_tests:

#b gip_prefetch_0
set vcd_skip_length 0
set run_length 40000
set_string vcd_filename "gip_prefetch_0"
setenv "memory_log_size" 16
setenv "stimulus_mif" "prefetch_simple_stimulus.mif"
setenv "instruction_ram" "prefetch_simple_sram.mif"
gosub gip_prefetch_test

#b Done
return

#a Gip tests - GIP without all the extra system infrastructure - kinda passe, but could be made to run
#f gip_tests
gip_tests:

setenv "verbose_level" 1

#gosub gip_0
#gosub gip_1

set vcd_create 1
gosub gip_uart
return

set vcd_create 0
gosub gip_linux
return

set vcd_create 0
gosub gip_memory
gosub gip_factorial
gosub gip_arm_alu
return

#b gip_0
gip_0:
set vcd_skip_length 0
set run_length 400
set_string vcd_filename "gip_0"
setenv "memory_log_size" 16
setenv "gip_iram_mif" "bin/gip_iram_0.mif"
setenv "gip_dram_mif" "data/none.mif"
setenv "post_rom_mif" "data/none.mif"
gosub gip_test
return

#b gip_1
gip_1:
set vcd_skip_length 0
#set run_length 40000000
set run_length 400
set_string vcd_filename "gip_1"
setenv "memory_log_size" 16
setenv "gip_iram_mif" "bin/gip_iram_1.mif"
setenv "gip_dram_mif" "data/gip_dram_1.mif"
setenv "post_rom_mif" "data/none.mif"
gosub gip_test
return

#b gip_uart
gip_uart:
set vcd_skip_length 0
#set run_length 40000000
set run_length 10000
set_string vcd_filename "gip_uart"
setenv "memory_log_size" 16
setenv "gip_iram_mif" "../arm/bin/uart.mif"
setenv "gip_dram_mif" "data/none.mif"
setenv "post_rom_mif" "data/none.mif"
gosub gip_test
return

#b gip_memory
gip_memory:
set vcd_skip_length 0
#set run_length 40000000
set run_length 10000
set_string vcd_filename "gip_memory"
setenv "memory_log_size" 16
setenv "gip_iram_mif" "../arm/bin/memory.mif"
setenv "gip_dram_mif" "data/none.mif"
setenv "post_rom_mif" "data/none.mif"
gosub gip_test
return

#b gip_factorial
gip_factorial:
set vcd_skip_length 0
set run_length 10000
set_string vcd_filename "gip_factorial"
setenv "memory_log_size" 16
setenv "gip_iram_mif" "../arm/bin/factorial.mif"
setenv "gip_dram_mif" "data/none.mif"
setenv "post_rom_mif" "data/none.mif"
gosub gip_test
return

#b gip_arm_alu
gip_arm_alu:
set vcd_skip_length 0
set run_length 80000
set_string vcd_filename "gip_arm_alu"
setenv "memory_log_size" 16
setenv "gip_iram_mif" "../arm/bin/alu.mif"
setenv "gip_dram_mif" "data/none.mif"
setenv "post_rom_mif" "data/none.mif"
gosub gip_test
return

#b gip_linux
gip_linux:
set vcd_skip_length 0
set run_length 200000
set_string vcd_filename "gip_linux"
# 16 MB of RAM!
setenv "memory_log_size" 22
# 64 MB of RAM!
setenv "memory_log_size" 24
setenv "gip_iram_mif" "/home/localgjs/tnbt_cvs_trees/software/os/linux/combined.mif"
setenv "gip_dram_mif" "data/none.mif"
setenv "post_rom_mif" "data/none.mif"
gosub gip_test
return

#a GIP system ALU tests
#f gip_system_alu
gip_system_alu:
setenv "verbose_level" 1

    gosub gip_system_alu_0
return

#b gip_system_alu_0
# This test runs the linux div64 function
gip_system_alu_0:
set vcd_skip_length 0
set run_length 100000
setenv "mii_rx_sources" ""
setenv "uart_exec_file" "src/end.ef"
setenv "ddr_mif" "../arm/bin/test_div64.regression.dmif"
set_string vcd_filename "gip_system_0"
set vcd_create 1
gosub gip_system_test
return

#a GIP system microkernel tests
#f gip_system_microkernel
gip_system_microkernel:
setenv "verbose_level" 1

#    gosub gip_system_microkernel_1
    gosub gip_system_microkernel_2
return

#b gip_system_microkernel_1
gip_system_microkernel_1:
set vcd_skip_length 0
set run_length 430000
setenv "mii_rx_sources" ""
setenv "uart_exec_file" "src/end.ef"
setenv "ddr_mif" "../arm/bin/microkernel_test_1.regression.dmif"
set_string vcd_filename "gip_system_0"
set vcd_create 0
gosub gip_system_test
return

#b gip_system_microkernel_2
gip_system_microkernel_2:
set vcd_skip_length 0
set run_length 200000
setenv "mii_rx_sources" ""
setenv "uart_exec_file" "src/end.ef"
setenv "ddr_mif" "../arm/bin/microkernel_test_2.regression.dmif"
setenv "ddr_mif" "../arm/bin/factorial.regression.dmif"
set_string vcd_filename "gip_system_0"
set vcd_create 1
gosub gip_system_test
return

#a GIP system scheduler tests
#f gip_system_scheduler
gip_system_scheduler:
setenv "verbose_level" 1

    gosub gip_system_scheduler_0
    gosub gip_system_scheduler_1
return

#b gip_system_scheduler_0
# This test runs the scheduler and tests different round robin, cooperative and preemptive modes - it is not exhastive as to preempting different instruction types, though
gip_system_scheduler_0:
set vcd_skip_length 0
set run_length 600000
setenv "mii_rx_sources" ""
setenv "uart_exec_file" "src/end.ef"
setenv "ddr_mif" "../arm/bin/scheduler_modes.regression.dmif"
set_string vcd_filename "gip_system_0"
set vcd_create 0
gosub gip_system_test
return

#b gip_system_scheduler_1
# This test runs the scheduler and tests different instruction preemptions
gip_system_scheduler_1:
# we run at about 1M cycles in 30s
set vcd_create 0
set vcd_skip_length 85000
set run_length 1100000
setenv "mii_rx_sources" ""
setenv "uart_exec_file" "src/end.ef"
setenv "ddr_mif" "../arm/bin/scheduler_preempt.regression.dmif"
set_string vcd_filename "gip_system_0"
gosub gip_system_test
return

#a GIP system ethernet tests
#f gip_system_ethernet:
gip_system_ethernet:
setenv "verbose_level" 1

    gosub gip_system_ethernet_reset
    gosub gip_system_scheduler_1
return

#b gip_system_ethernet_0
gip_system_ethernet_0:
set vcd_skip_length 0
#set run_length 400000
set run_length 32000
set vcd_create 1
setenv "mii_rx_sources" "( ) ( ( i 64 0x1234 0 0 ) )"
setenv "uart_exec_file" "src/gip_ddr_uart_0.ef"
setenv "ddr_mif" "../arm/bin/ethernet.regression.dmif"
set_string vcd_filename "gip_system_0"
gosub gip_system_test
return

#b gip_system_1
gip_system_1:
set vcd_skip_length 0
set run_length 40000
set vcd_create 1
setenv "mii_rx_sources" "( ) ( ( i 64 0x1234 0 0 ) )"
setenv "uart_exec_file" "src/gip_ddr_uart_0.ef"
setenv "ddr_mif" "../arm/bin/ethernet.regression.dmif"
set_string vcd_filename "gip_system_0"
gosub gip_system_test
return

#b gip_system_ethernet_reset
gip_system_ethernet_reset:
set vcd_skip_length 180000
set run_length 280000
set vcd_create 0
setenv "mii_rx_sources" "( ) ( ( c 144 0x1234 0x55555555 0 10000 0 ) )"
setenv "uart_exec_file" "src/end.ef"
# We need this to wait >1250 cycles (>120,000ns) before checking it has run twice; the eth packet takes about that to get in
setenv "ddr_mif" "../arm/bin/inc_wait_test.regression.dmif"
set_string vcd_filename "gip_system_0"
gosub gip_system_test
return

#a Hardware variations
#f gip_prefetch_test
gip_prefetch_test:

read_hw_file gip_prefetch.hwex

beq vcd_create 0 gip_prefetch_test_no_vcd    
sprintf vcd_full_filename "%s0%/%s1%.vcd" env_string("run_dir") vcd_filename
vcd_file_open "allsignals" vcd_full_filename
vcd_file_add "allsignals" "gip_prefetch" "instruction_sram"
reset
step vcd_skip_length
vcd_file_enable "allsignals"
sub run_length run_length vcd_skip_length
step run_length
vcd_file_close "allsignals"
return

gip_prefetch_test_no_vcd:
reset
step run_length
return

#f gip_system_test
gip_system_test:

read_hw_file gip_system.hwex

beq vcd_create 0 gip_system_test_no_vcd
sprintf vcd_full_filename "%s0%/%s1%.vcd" env_string("run_dir") vcd_filename
vcd_file_open "allsignals" vcd_full_filename
vcd_file_add "allsignals" "gip_simple"
#vcd_file_add "allsignals" "system"
vcd_file_add "allsignals" "gip_simple.gip.gip.postbus"
vcd_file_add "allsignals" "gip_simple.gip.gip.special"
vcd_file_add "allsignals" "gip_simple.gip.gip.scheduler"
#vcd_file_add "allsignals" "gip_system.prefetch" "gip_system.data_ram" "gip_system.boot_rom" "gip_system.shared_sram"
vcd_file_add "allsignals" "gip_simple.gip.gip.decode" "gip_simple.gip.gip.decode.native" "gip_simple.gip.gip.decode.arm"
vcd_file_add "allsignals" "gip_simple.gip.gip.rf"
vcd_file_add "allsignals" "gip_simple.gip.gip.alu"
vcd_file_add "allsignals" "gip_simple.gip.gip.alu.shift_op"
#vcd_file_add "allsignals" "gip_simple.gip_apb"
vcd_file_add "allsignals" "gip_simple.iob.pst.src"
vcd_file_add "allsignals" "gip_simple.iob.pst.tgt"
vcd_file_add "allsignals" "gip_simple.iob.pst.event_mgr"
vcd_file_add "allsignals" "gip_simple.iob"
vcd_file_add "allsignals" "gip_simple.iob.ss"
vcd_file_add "allsignals" "gip_simple.iob.ingress_fifos"
vcd_file_add "allsignals" "gip_simple.iob.egress_fifos"
vcd_file_add "allsignals" "mii"
#vcd_file_add "allsignals" "gip_simple.iob"
#vcd_file_add "allsignals" "gip_system.uart_apb" "gip_system.uart_apb.status_fifo"  "gip_system.uart_apb.cmd_fifo" "gip_system.uart_io"
#vcd_file_add "allsignals" "gip_system.ext_bus_apb"
vcd_file_add "allsignals" "rxd" "txd"
reset
step vcd_skip_length
vcd_file_enable "allsignals"
sub run_length run_length vcd_skip_length
step run_length
vcd_file_close "allsignals"
return

gip_system_test_no_vcd:
reset
step run_length
return


#b Done
return

#f gip_test
gip_test:

read_hw_file gip.hwex

beq vcd_create 0 gip_test_no_vcd
sprintf vcd_full_filename "%s0%/%s1%.vcd" env_string("run_dir") vcd_filename
vcd_file_open "allsignals" vcd_full_filename
vcd_file_add "allsignals" "gipc"
vcd_file_add "allsignals" "gip_prefetch" "gip_data_ram" "shared_sram"
vcd_file_add "allsignals" "gipc.decode" "gipc.decode.native""gipc.decode.arm" "gipc.rf" "gipc.alu" "gipc.alu.shift_op"
vcd_file_add "allsignals" "gip_periph_apb" "apb_target_uart" "io_uart"
reset
step vcd_skip_length
vcd_file_enable "allsignals"
sub run_length run_length vcd_skip_length
step run_length
vcd_file_close "allsignals"
return

gip_test_no_vcd:
reset
step run_length
return

#a Editor preferences and notes
# Local Variables: ***
# mode: shell-script ***
# outline-regexp: "#[a!]\\\|#[\t ]*[b-z][\t ]" ***
# End: ***
